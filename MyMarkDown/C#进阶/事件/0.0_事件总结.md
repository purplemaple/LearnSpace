## 0.0_事件总结

1. 定义：事件是使对象或类具备"通知能力"的"成员"
2. 使用：用于对象或类间的动作协调与信息传递(消息推送)
   - 当事件发生时，关心这个事件的对象们纷纷做出响应
3. 事件的功能：通知 + 可选的事件参数(即关于事件的详细信息)
   - 有事件参数，如：手机响了 + 闹钟  --> 通知你时间到了；手机响了 + 电话号码 --> 通知你来电话了
   - 无事件参数，如：红灯亮了 --> 刹车 (指即使不携带别的信息，仅事件发生了，也能知道接下来该怎么做)
4. 事件与委托的关系：事件是基于委托的
   - 事件需要委托类型来做约束，响应者的事件处理器必须与这个约束匹配上，才能订阅这个事件(既规定了事件能发送什么样的消息给响应者，也规定了响应者能收到什么样的消息)
   - 当响应者提供了事件处理器时，总得找个地方将这个处理器方法保存或记录下来，而能够记录或引用方法的任务，只有委托能做到
   - 因此，事件无论存表层约束还是底层实现，都依赖于委托
   - 详见于 "注" 第4条


**注：**
1. 事件不会自己发生！
2. 一个事件可以同时挂接多个事件处理器(如案例1.1)`timer.Elapsed += girl.SingAction;` `timer.Elapsed += girl.SingAction;`
3. 一个事件处理器可以订阅多个事件(如案例1.5)`button1.Click += ButtonClicked` `button2.Click += ButtonClicked`
4. 事件拥有者内部其实有一个用于约束的委托类型字段
   - 给事件挂载事件处理器时，实际上是挂载到了事件拥有者内部的委托字段上！
   - 当触发事件时，实际上是调用这个委托字段的Invoke方法，执行所有挂载的事件处理器。
     - 对于完整声明格式的事件，这个委托字段就由程序员手动定义(如案例2.1)
     - 对于简化声明格式的事件，这个委托字段不手动定义，但在编译时由编译器自动生成(如案例2.2，类似于自动属性，编译器会生成字段)
5. 可用自带的 `EventHandler(object sender, EventArgs e)` 委托来节省我们自定义委托的过程
   -  注意：这里是节省了自定义委托的步骤，不是和案例 2.2 那样节省了委托字段！(这是两个不同的东西) 

经过一段时间学习后得知：  
**事件的本质就是委托类型字段的一个包装器！(注意：委托类型字段不等同于委托类型)**

心得：委托字段与事件的关系就像字段与属性的关系，相似点如下：
1. 事件就是对于事件拥有者内对应的那个委托字段的包装 ---> 类似于属性就是对字段的包装
   - 在外部对事件进行挂载或卸载时，实际上就是在对委托字段进行 += 操作和 -= 操作 ---> 类似于属性的 get、set，实际是返回和设置字段
   - 前两者也有完整声明方式和简化声明方式，当简化声明时不手动定义委托字段，而由编译器自动生成 ---> 类似于自动属性，编译时生成字段
   - 包装是为了防止在外部被滥用、篡改 ---> 类似于属性与字段，只让操作属性，不让操作字段(当然，由于都是采用 private 关键字，所以都能被反射破解)
2. 为什么要用委托类型来声明事件？
   - 从事件拥有者角度看，是为了表明其能对外传递哪些消息
   - 从事件响应者角度看，是为了约束其能使用哪种处理器(签名必须相同)来处理事件
   - 事件处理器需要存储，而能存储方法的类型正式委托类型

事件相关命名准则：
1. 委托命名为：事件名 + EventHandler。如：`OrderEventHandler`
2. 事件参数类命名为：事件名 + EventArgs。如：`OrderEventArgs`
3. 触发事件的方法(即将触发事件过程封装的方法，见案例2.5)命名为：On + 事件名。如：`OnOrder`